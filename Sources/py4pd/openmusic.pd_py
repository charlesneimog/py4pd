import puredata as pd
import functools
import operator

pd.post("OpenMusic library from py4pd")
pd.post("By Charles K. Neimog")

# class pyand(pd.NewObject):
#     name = "py.and"
#     # TODO: Precisa implementar um jeito de executar coisas em multiplos inlets
#
#     def __init__(self, args):
#         self.outlets = 1
#         if len(args) > 0:
#             self.inlets = args[0]
#         else:
#             self.inlets = 2

# class pyor(pd.NewObject):
# class pyequal(pd.NewObject):
# class pyand(pd.NewObject):
# class pyand(pd.NewObject):
# class pyhigherthen(pd.NewObject):
# class pylowerthen(pd.NewObject):
# class py2pd(pd.NewObject):
# class pd2py(pd.NewObject):


class openmusic(pd.NewObject):
    name = "openmusic"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_1_reload(self, args):
        self.reload()


class pyprint(pd.NewObject):
    name = "py.print"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_1_pyobj_list(self, thing):
        self.logpost(2, thing)


class pymklist(pd.NewObject):
    name = "py.mklist"

    def __init__(self, args):
        if len(args) > 0:
            self.inlets = int(args[0])
        else:
            self.inlets = 2
        self.outlets = 1
        self.mklist_list = [[] for _ in range(self.inlets)]

        for i in range(2, self.inlets + 1):
            method_name = f"in_{i}_list"
            bound_method = functools.partial(self._list_method, inlet_index=i)
            setattr(self, method_name, bound_method)

    def _list_method(self, l: list, inlet_index: int):
        self.mklist_list[inlet_index - 1] = l

    def in_1_list(self, l: list):
        self.mklist_list[0] = l
        self.out(0, pd.PYOBJECT, self.mklist_list)


# ╭──────────────────────────────────────╮
# │             Simple Math              │
# ╰──────────────────────────────────────╯
class _PyMathBase(pd.NewObject):
    """Classe base para operações matemáticas em múltiplos inlets"""

    name = ""

    def __init__(self, args):
        if len(args) > 0:
            self.inlets = int(args[0])
        else:
            self.inlets = 2
        self.outlets = 1
        self.mklist_list = [[] for _ in range(self.inlets)]

        for i in range(2, self.inlets + 1):
            setattr(
                self,
                f"in_{i}_list",
                functools.partial(self._list_method, inlet_index=i),
            )
            setattr(
                self,
                f"in_{i}_float",
                functools.partial(self._float_method, inlet_index=i),
            )

    def _list_method(self, l: list, inlet_index: int):
        self.mklist_list[inlet_index - 1] = l

    def _float_method(self, f: float, inlet_index: int):
        self.mklist_list[inlet_index - 1] = [f]

    def _compute(self):
        if not all(len(lst) == len(self.mklist_list[0]) for lst in self.mklist_list):
            return None
        result = []
        for values in zip(*self.mklist_list):
            res = values[0]
            for v in values[1:]:
                res = self.operation(res, v)
            result.append(res)
        return result

    def in_1_list(self, l: list):
        self.mklist_list[0] = l
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)

    def in_1_float(self, f: float):
        if not self.mklist_list[0]:
            self.mklist_list[0] = [f]
        else:
            self.mklist_list[0][0] = f
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)


# Classes com 'name' explícito
class pyplus(_PyMathBase):
    name = "py+"
    operation = operator.add


class pyminus(_PyMathBase):
    name = "py-"
    operation = operator.sub


class pymult(_PyMathBase):
    name = "py*"
    operation = operator.mul


class pydiv(_PyMathBase):
    name = "py/"
    operation = operator.truediv


# ╭──────────────────────────────────────╮
# │                Lists                 │
# ╰──────────────────────────────────────╯
class pynth(pd.NewObject):
    name = "py.nth"

    def __init__(self, args):
        if len(args) < 1:
            raise Exception("Missing arguments")

        self.nth = int(args[0])
        self.inlets = 1
        self.outlets = 1

    def in_1_pyobj_list(self, l: list):
        self.out(0, pd.PYOBJECT, l[self.nth])


# ──────────────────────────────────────
class pylen(pd.NewObject):
    name = "py.len"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1

    def in_1_pyobj_list(self, l: list):
        length = len(l)
        self.out(0, pd.FLOAT, length)


# ──────────────────────────────────────
class _PyCompareBase(pd.NewObject):
    """Classe base para max/min em múltiplos inlets"""

    operation = None  # função max ou min
    name = ""

    def __init__(self, args):
        if len(args) > 0:
            self.inlets = int(args[0])
        else:
            self.inlets = 2
        self.outlets = 1
        self.mklist_list = [[] for _ in range(self.inlets)]

        for i in range(2, self.inlets + 1):
            setattr(
                self,
                f"in_{i}_list",
                functools.partial(self._list_method, inlet_index=i),
            )
            setattr(
                self,
                f"in_{i}_float",
                functools.partial(self._float_method, inlet_index=i),
            )

    def _list_method(self, l: list, inlet_index: int):
        self.mklist_list[inlet_index - 1] = l

    def _float_method(self, f: float, inlet_index: int):
        self.mklist_list[inlet_index - 1] = [f]

    def _compute(self):
        if not all(len(lst) == len(self.mklist_list[0]) for lst in self.mklist_list):
            return None
        result = []
        for values in zip(*self.mklist_list):
            result.append(self.operation(values))
        return result

    def in_1_list(self, l: list):
        self.mklist_list[0] = l
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)

    def in_1_float(self, f: float):
        if not self.mklist_list[0]:
            self.mklist_list[0] = [f]
        else:
            self.mklist_list[0][0] = f
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)


# Implementações específicas
class pymax(_PyCompareBase):
    name = "py.max"
    operation = max


class pymin(_PyCompareBase):
    name = "py.min"
    operation = min


# ──────────────────────────────────────
class pyexpr(pd.NewObject):
    name = "py.expr"

    def __init__(self, args):
        for a in args:
            if "$f" in a:
                pd.post("float  input")
            elif "$i" in a:
                pd.post("int    input")
            elif "$s" in a:
                pd.post("symbol input")

        self.inlets = 1
        self.outlets = 1


# py.append
# py.reduce
# py.mattrans
# py.rotate
# py.flat
# py.np2list       # only if numpyInstalled
# py.list2np       # only if numpyInstalled
# py.iterate
# py.collect
# py.recursive
# py.trigger
# py.gate
# py.abs
# py//
# py.listcomp
# py.rhythm_tree
# py.arithm-ser
# py.show
# py.f2mc
# py.mc2f
# py.mc2n
# py.timer
# py.memuse
