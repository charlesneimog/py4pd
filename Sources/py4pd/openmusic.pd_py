import puredata as pd
import functools
import operator
import random
import math
from typing import Any, Callable, Iterable, List, Sequence, Union

pd.post("OpenMusic library from py4pd")
pd.post("by Charles K. Neimog (2025)")


class openmusic(pd.NewObject):
    name = "openmusic"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_0_reload(self, args):
        self.reload()


class pyprint(pd.NewObject):
    name = "py.print"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_0_pyobj(self, thing):
        self.logpost(2, thing)


class pymklist(pd.NewObject):
    name = "py.mklist"

    def __init__(self, args):
        if len(args) > 0:
            self.inlets = int(args[0])
        else:
            self.inlets = 2
        self.outlets = 1
        self.mklist_list = [[] for _ in range(self.inlets)]

        for i in range(2, self.inlets + 1):
            method_name = f"in_{i}_list"
            bound_method = functools.partial(self._list_method, inlet_index=i)
            setattr(self, method_name, bound_method)

    def _list_method(self, l: list, inlet_index: int):
        self.mklist_list[inlet_index - 1] = l

    def in_0_list(self, l: list):
        self.mklist_list[0] = l
        self.out(0, pd.PYOBJECT, self.mklist_list)


# ╭──────────────────────────────────────╮
# │             Simple Math              │
# ╰──────────────────────────────────────╯
class _PyMathBase(pd.NewObject):
    """Classe base para operações matemáticas em múltiplos inlets"""

    name = ""

    def __init__(self, args):
        if len(args) > 0:
            self.inlets = int(args[0])
        else:
            self.inlets = 2
        self.outlets = 1
        self.mklist_list = [[] for _ in range(self.inlets)]

        for i in range(2, self.inlets + 1):
            setattr(
                self,
                f"in_{i}_list",
                functools.partial(self._list_method, inlet_index=i),
            )
            setattr(
                self,
                f"in_{i}_float",
                functools.partial(self._float_method, inlet_index=i),
            )

            setattr(
                self,
                f"in_{i}_pyobj",
                functools.partial(self._pyobj_method, inlet_index=i),
            )

    def _list_method(self, l: list, inlet_index: int):
        self.mklist_list[inlet_index - 1] = l

    def _float_method(self, f: float, inlet_index: int):
        self.mklist_list[inlet_index - 1] = [f]

    def _pyobj_method(self, f, inlet_index: int):
        self.mklist_list[inlet_index - 1] = [f]

    def _compute(self):
        if not all(len(lst) == len(self.mklist_list[0]) for lst in self.mklist_list):
            return None
        result = []
        for values in zip(*self.mklist_list):
            res = values[0]
            for v in values[1:]:
                res = self.operation(res, v)
            result.append(res)
        return result

    def in_0_pyobj(self, l):
        if isinstance(l, list):
            self.in_0_list(l)
        elif isinstance(l, float) or isinstance(l, int):
            self.in_0_float(l)
        else:
            raise Exception("Invalid type")

    def in_0_list(self, l):
        self.mklist_list[0] = l
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)

    def in_0_float(self, f):
        if not self.mklist_list[0]:
            self.mklist_list[0] = [f]
        else:
            self.mklist_list[0][0] = f
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value[0])


# Classes com 'name' explícito
class pyplus(_PyMathBase):
    name = "py+"
    operation = operator.add


class pyminus(_PyMathBase):
    name = "py-"
    operation = operator.sub


class pymult(_PyMathBase):
    name = "py*"
    operation = operator.mul


class pydiv(_PyMathBase):
    name = "py/"
    operation = operator.truediv


# ╭──────────────────────────────────────╮
# │                Lists                 │
# ╰──────────────────────────────────────╯
class pynth(pd.NewObject):
    name = "py.nth"

    def __init__(self, args):
        if len(args) < 1:
            raise Exception("Missing arguments")

        self.nth = int(args[0])
        self.inlets = 1
        self.outlets = 1

    def in_0_pyobj(self, l: list):
        self.out(0, pd.PYOBJECT, l[self.nth])


# ──────────────────────────────────────
class pylen(pd.NewObject):
    name = "py.len"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1

    def in_0_pyobj(self, l: list):
        length = len(l)
        self.out(0, pd.FLOAT, length)


# ──────────────────────────────────────
class _PyCompareBase(pd.NewObject):
    """Classe base para max/min em múltiplos inlets"""

    operation = None  # função max ou min
    name = ""

    def __init__(self, args):
        if len(args) > 0:
            self.inlets = int(args[0])
        else:
            self.inlets = 2
        self.outlets = 1
        self.mklist_list = [[] for _ in range(self.inlets)]

        for i in range(2, self.inlets + 1):
            setattr(
                self,
                f"in_{i}_list",
                functools.partial(self._list_method, inlet_index=i),
            )
            setattr(
                self,
                f"in_{i}_float",
                functools.partial(self._float_method, inlet_index=i),
            )

    def _list_method(self, l: list, inlet_index: int):
        self.mklist_list[inlet_index - 1] = l

    def _float_method(self, f: float, inlet_index: int):
        self.mklist_list[inlet_index - 1] = [f]

    def _compute(self):
        if not all(len(lst) == len(self.mklist_list[0]) for lst in self.mklist_list):
            return None
        result = []
        for values in zip(*self.mklist_list):
            result.append(self.operation(values))
        return result

    def in_0_list(self, l: list):
        self.mklist_list[0] = l
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)

    def in_0_float(self, f: float):
        if not self.mklist_list[0]:
            self.mklist_list[0] = [f]
        else:
            self.mklist_list[0][0] = f
        value = self._compute()
        if value is not None:
            self.out(0, pd.PYOBJECT, value)

    def in_0_pyobj(self, values):
        if isinstance(values, list):
            self.in_0_list(values)
        elif isinstance(values, float):
            self.in_0_float(values)


# Implementações específicas
class pymax(_PyCompareBase):
    name = "py.max"
    operation = max


class pymin(_PyCompareBase):
    name = "py.min"
    operation = min


# ──────────────────────────────────────
class pyexpr(pd.NewObject):
    name = "py.expr"

    def __init__(self, args):
        for a in args:
            if "$f" in a:
                pd.post("float  input")
            elif "$i" in a:
                pd.post("int    input")
            elif "$s" in a:
                pd.post("symbol input")

        self.inlets = 1
        self.outlets = 1


# ╭──────────────────────────────────────╮
# │            Python Methods            │
# ╰──────────────────────────────────────╯
class pydir(pd.NewObject):
    name = "py.dir"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_0_pyobj(self, l):
        set_get = dir(l)
        good = []
        for m in set_get:
            if m[0] != "_":
                good.append(m)
        pd.post(good)


# ──────────────────────────────────────
class pygetattr(pd.NewObject):
    name = "py.getattr"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1
        if len(args) == 0:
            raise Exception("Required attr name")

        self.attr = args[0]

    def in_0_pyobj(self, l):
        self.out(0, pd.PYOBJECT, getattr(l, self.attr))


# ╭──────────────────────────────────────╮
# │             Python Loop              │
# ╰──────────────────────────────────────╯
import uuid

id_unico = uuid.uuid4()


class pyiterate(pd.NewObject):
    name = "py.iterate"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 2

    def in_0_list(self, l):
        self.out(1, pd.PYOBJECT, "iterate_init-" + str(id_unico))
        for i in l:
            self.out(0, pd.PYOBJECT, i)
        self.out(1, pd.PYOBJECT, "iterate_end-" + str(id_unico))

    def in_0_pyobj(self, l):
        self.out(1, pd.PYOBJECT, "iterate_init-" + str(id_unico))
        for i in l:
            pd.post(i)
            self.out(0, pd.PYOBJECT, i)
        self.out(1, pd.PYOBJECT, "iterate_end-" + str(id_unico))

    def in_0_reload(self, args):
        self.reload()


class pycollect(pd.NewObject):
    name = "py.collect"

    def __init__(self, args):
        self.inlets = 2
        self.outlets = 1
        self.collected = []

    def in_0_pyobj(self, thing):
        self.collected.append(thing)

    def in_1_pyobj(self, method):
        if method == "iterate_init-" + str(id_unico):
            self.collected = []
        elif method == "iterate_end-" + str(id_unico):
            self.out(0, pd.PYOBJECT, self.collected)

    def in_0_reload(self, args):
        self.reload()


# TODO: List Processing
# '(last-elem last-n first-n  x-append flat create-list expand-lst iterate-list
#                              mat-trans group-list n-group-list remove-dup remove-nth subs-posn interlock list-modulo
#                              list-explode list-filter table-filter band-filter range-filter posn-match apply-lambda-seq om-choose)

# TODO: List utilities
# (all-atoms? all-lists? treedepth member-pos) *list-utils-package*)

# TODO: ARITHMETICS
# (om+ om- om* om/ om// om^ om-e om-abs om-min om-max
#                    list-min list-max om-mean om-log om-round om-scale om-scale^ om-scale/sum reduce-tree
#                    interpolation factorize om-clip om-random perturbation
#                    om-cos om-sin

#
# ;;; COMBINATORIAL
# (defvar *comb-package* (omNG-protect-object (omNG-make-new-package "Combinatorial")))
# (AddGenFun2Pack '(sort-list group-cons remove-iter rotate nth-random permut-random posn-order permutations) *comb-package*)
# (AddPackage2Pack *comb-package* *basic-package*)
#
# ;;; SERIES
# (defvar *numser-package* (omNG-protect-object (omNG-make-new-package "Series")))
# (AddGenFun2Pack '(arithm-ser geometric-ser fibo-ser inharm-ser prime-ser prime? x->dx dx->x) *numser-package* )
# (AddPackage2Pack *numser-package* *basic-package*)
#
# ;;; SETS
# (defvar *set-package* (omNG-protect-object (omNG-make-new-package "Sets")))
# (AddGenFun2Pack  '(x-union x-intersect x-Xor x-diff included?) *set-package*)
# (AddPackage2Pack *set-package* *basic-package*)
#
#
# ;;; FUNCTIONS
# (defvar *function-package* (omNG-protect-object (omNG-make-new-package "Curves & Functions")))
#
# (AddGenFun2Pack '(point-pairs om-sample
#                               x-transfer y-transfer
#                               om-spline
#                               linear-fun bpf-interpol
#                               reduce-points reduce-n-points
#                               bpf-offset bpf-crossfade bpf-extract bpf-scale
#                               bpf-stretch bpf-concat
#                               om-rotate om-translate om-mirror
#                               export-svg import-svg
#                               ) *function-package*)
#
# ;;; DATA STRUCTURES
# (defvar *basic-data-package* (omNG-protect-object (omNG-make-new-package "Array")))
# (AddGenFun2Pack '(new-comp get-comp comp-list comp-field add-comp remove-comp) *basic-data-package*)
# (AddClass2Pack '(class-array) *basic-data-package* :position (list (om-make-point 175 50)))
# (AddPackage2Pack *basic-data-package* *basic-package*)
